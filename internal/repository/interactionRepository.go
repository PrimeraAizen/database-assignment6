package repository

import (
	"context"
	"fmt"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo/options"

	"github.com/PrimeraAizen/e-comm/internal/domain"
	mongodb "github.com/PrimeraAizen/e-comm/pkg/adapter/mongodb"
)

type InteractionRepository interface {
	// View interactions
	RecordView(ctx context.Context, userID, productID int) error
	GetUserViews(ctx context.Context, userID int, limit int) ([]domain.ProductInteraction, error)
	HasViewed(ctx context.Context, userID, productID int) (bool, error)

	// Like interactions
	RecordLike(ctx context.Context, userID, productID int) error
	RemoveLike(ctx context.Context, userID, productID int) error
	GetUserLikes(ctx context.Context, userID int, limit int) ([]domain.ProductInteraction, error)
	HasLiked(ctx context.Context, userID, productID int) (bool, error)

	// Purchase interactions
	RecordPurchase(ctx context.Context, userID, productID int, quantity int, price float64) error
	GetUserPurchases(ctx context.Context, userID int, limit int) ([]domain.ProductInteraction, error)
	HasPurchased(ctx context.Context, userID, productID int) (bool, error)

	// Summary
	GetUserInteractionSummary(ctx context.Context, userID int) (*domain.UserInteractionSummary, error)

	// For recommendations
	GetAllUserViews(ctx context.Context) ([]domain.UserProductView, error)
	GetAllUserLikes(ctx context.Context) ([]domain.UserProductLike, error)
	GetAllUserPurchases(ctx context.Context) ([]domain.UserProductPurchase, error)
}

type interactionRepository struct {
	db *mongodb.MongoDB
}

func NewInteractionRepository(db *mongodb.MongoDB) InteractionRepository {
	return &interactionRepository{db: db}
}

// RecordView records a user viewing a product
func (r *interactionRepository) RecordView(ctx context.Context, userID, productID int) error {
	collection := r.db.Collection("user_product_views")

	view := domain.UserProductView{
		UserID:    userID,
		ProductID: productID,
		ViewedAt:  time.Now(),
	}

	_, err := collection.InsertOne(ctx, view)
	if err != nil {
		return fmt.Errorf("record view: %w", err)
	}

	return nil
}

// GetUserViews retrieves products a user has viewed
func (r *interactionRepository) GetUserViews(ctx context.Context, userID int, limit int) ([]domain.ProductInteraction, error) {
	collection := r.db.Collection("user_product_views")

	// Aggregation pipeline to get product details
	pipeline := []bson.M{
		{"$match": bson.M{"user_id": userID}},
		{"$sort": bson.M{"viewed_at": -1}},
		{"$limit": limit},
		{"$lookup": bson.M{
			"from":         "products",
			"localField":   "product_id",
			"foreignField": "_id",
			"as":           "product",
		}},
		{"$unwind": "$product"},
		{"$project": bson.M{
			"product_id":    "$product_id",
			"product_name":  "$product.name",
			"category_id":   "$product.category_id",
			"price":         "$product.price",
			"interacted_at": "$viewed_at",
		}},
	}

	cursor, err := collection.Aggregate(ctx, pipeline)
	if err != nil {
		return nil, fmt.Errorf("get user views: %w", err)
	}
	defer cursor.Close(ctx)

	var interactions []domain.ProductInteraction
	if err := cursor.All(ctx, &interactions); err != nil {
		return nil, fmt.Errorf("decode user views: %w", err)
	}

	return interactions, nil
}

// HasViewed checks if a user has viewed a product
func (r *interactionRepository) HasViewed(ctx context.Context, userID, productID int) (bool, error) {
	collection := r.db.Collection("user_product_views")

	count, err := collection.CountDocuments(ctx, bson.M{
		"user_id":    userID,
		"product_id": productID,
	})
	if err != nil {
		return false, err
	}

	return count > 0, nil
}

// RecordLike records a user liking a product
func (r *interactionRepository) RecordLike(ctx context.Context, userID, productID int) error {
	collection := r.db.Collection("user_product_likes")

	// Check if already liked
	count, err := collection.CountDocuments(ctx, bson.M{
		"user_id":    userID,
		"product_id": productID,
	})
	if err != nil {
		return fmt.Errorf("check existing like: %w", err)
	}

	if count > 0 {
		return nil // Already liked, no error
	}

	like := domain.UserProductLike{
		UserID:    userID,
		ProductID: productID,
		LikedAt:   time.Now(),
	}

	_, err = collection.InsertOne(ctx, like)
	if err != nil {
		return fmt.Errorf("record like: %w", err)
	}

	return nil
}

// RemoveLike removes a user's like from a product
func (r *interactionRepository) RemoveLike(ctx context.Context, userID, productID int) error {
	collection := r.db.Collection("user_product_likes")

	result, err := collection.DeleteOne(ctx, bson.M{
		"user_id":    userID,
		"product_id": productID,
	})
	if err != nil {
		return fmt.Errorf("remove like: %w", err)
	}

	if result.DeletedCount == 0 {
		return domain.ErrNotFound
	}

	return nil
}

// GetUserLikes retrieves products a user has liked
func (r *interactionRepository) GetUserLikes(ctx context.Context, userID int, limit int) ([]domain.ProductInteraction, error) {
	collection := r.db.Collection("user_product_likes")

	// Aggregation pipeline to get product details
	pipeline := []bson.M{
		{"$match": bson.M{"user_id": userID}},
		{"$sort": bson.M{"liked_at": -1}},
		{"$limit": limit},
		{"$lookup": bson.M{
			"from":         "products",
			"localField":   "product_id",
			"foreignField": "_id",
			"as":           "product",
		}},
		{"$unwind": "$product"},
		{"$project": bson.M{
			"product_id":    "$product_id",
			"product_name":  "$product.name",
			"category_id":   "$product.category_id",
			"price":         "$product.price",
			"interacted_at": "$liked_at",
		}},
	}

	cursor, err := collection.Aggregate(ctx, pipeline)
	if err != nil {
		return nil, fmt.Errorf("get user likes: %w", err)
	}
	defer cursor.Close(ctx)

	var interactions []domain.ProductInteraction
	if err := cursor.All(ctx, &interactions); err != nil {
		return nil, fmt.Errorf("decode user likes: %w", err)
	}

	return interactions, nil
}

// HasLiked checks if a user has liked a product
func (r *interactionRepository) HasLiked(ctx context.Context, userID, productID int) (bool, error) {
	collection := r.db.Collection("user_product_likes")

	count, err := collection.CountDocuments(ctx, bson.M{
		"user_id":    userID,
		"product_id": productID,
	})
	if err != nil {
		return false, err
	}

	return count > 0, nil
}

// GetUserInteractionSummary gets a summary of all user interactions
func (r *interactionRepository) GetUserInteractionSummary(ctx context.Context, userID int) (*domain.UserInteractionSummary, error) {
	// Get views
	views, err := r.GetUserViews(ctx, userID, 50)
	if err != nil {
		return nil, err
	}

	// Get likes
	likes, err := r.GetUserLikes(ctx, userID, 50)
	if err != nil {
		return nil, err
	}

	// Get purchases
	purchases, err := r.GetUserPurchases(ctx, userID, 50)
	if err != nil {
		return nil, err
	}

	// Count totals
	viewsCollection := r.db.Collection("user_product_views")
	totalViews, err := viewsCollection.CountDocuments(ctx, bson.M{"user_id": userID})
	if err != nil {
		totalViews = 0
	}

	likesCollection := r.db.Collection("user_product_likes")
	totalLikes, err := likesCollection.CountDocuments(ctx, bson.M{"user_id": userID})
	if err != nil {
		totalLikes = 0
	}

	purchasesCollection := r.db.Collection("user_product_purchases")
	totalPurchases, err := purchasesCollection.CountDocuments(ctx, bson.M{"user_id": userID})
	if err != nil {
		totalPurchases = 0
	}

	summary := &domain.UserInteractionSummary{
		UserID:            userID,
		ViewedProducts:    views,
		LikedProducts:     likes,
		PurchasedProducts: purchases,
		TotalViews:        totalViews,
		TotalLikes:        totalLikes,
		TotalPurchases:    totalPurchases,
	}

	return summary, nil
}

// GetAllUserViews retrieves all user views (for recommendation algorithm)
func (r *interactionRepository) GetAllUserViews(ctx context.Context) ([]domain.UserProductView, error) {
	collection := r.db.Collection("user_product_views")

	opts := options.Find().SetSort(bson.M{"viewed_at": -1})
	cursor, err := collection.Find(ctx, bson.M{}, opts)
	if err != nil {
		return nil, fmt.Errorf("get all views: %w", err)
	}
	defer cursor.Close(ctx)

	var views []domain.UserProductView
	if err := cursor.All(ctx, &views); err != nil {
		return nil, fmt.Errorf("decode views: %w", err)
	}

	return views, nil
}

// GetAllUserLikes retrieves all user likes (for recommendation algorithm)
func (r *interactionRepository) GetAllUserLikes(ctx context.Context) ([]domain.UserProductLike, error) {
	collection := r.db.Collection("user_product_likes")

	opts := options.Find().SetSort(bson.M{"liked_at": -1})
	cursor, err := collection.Find(ctx, bson.M{}, opts)
	if err != nil {
		return nil, fmt.Errorf("get all likes: %w", err)
	}
	defer cursor.Close(ctx)

	var likes []domain.UserProductLike
	if err := cursor.All(ctx, &likes); err != nil {
		return nil, fmt.Errorf("decode likes: %w", err)
	}

	return likes, nil
}

// RecordPurchase records a user purchasing a product
func (r *interactionRepository) RecordPurchase(ctx context.Context, userID, productID int, quantity int, price float64) error {
	collection := r.db.Collection("user_product_purchases")

	purchase := domain.UserProductPurchase{
		UserID:          userID,
		ProductID:       productID,
		Quantity:        quantity,
		PriceAtPurchase: price,
		PurchasedAt:     time.Now(),
	}

	_, err := collection.InsertOne(ctx, purchase)
	if err != nil {
		return fmt.Errorf("record purchase: %w", err)
	}

	return nil
}

// GetUserPurchases retrieves products a user has purchased
func (r *interactionRepository) GetUserPurchases(ctx context.Context, userID int, limit int) ([]domain.ProductInteraction, error) {
	collection := r.db.Collection("user_product_purchases")

	// Aggregation pipeline to get product details
	pipeline := []bson.M{
		{"$match": bson.M{"user_id": userID}},
		{"$sort": bson.M{"purchased_at": -1}},
		{"$limit": limit},
		{"$lookup": bson.M{
			"from":         "products",
			"localField":   "product_id",
			"foreignField": "_id",
			"as":           "product",
		}},
		{"$unwind": "$product"},
		{"$project": bson.M{
			"product_id":    "$product_id",
			"product_name":  "$product.name",
			"category_id":   "$product.category_id",
			"price":         "$product.price",
			"interacted_at": "$purchased_at",
		}},
	}

	cursor, err := collection.Aggregate(ctx, pipeline)
	if err != nil {
		return nil, fmt.Errorf("get user purchases: %w", err)
	}
	defer cursor.Close(ctx)

	var interactions []domain.ProductInteraction
	if err := cursor.All(ctx, &interactions); err != nil {
		return nil, fmt.Errorf("decode user purchases: %w", err)
	}

	return interactions, nil
}

// HasPurchased checks if a user has purchased a product
func (r *interactionRepository) HasPurchased(ctx context.Context, userID, productID int) (bool, error) {
	collection := r.db.Collection("user_product_purchases")

	count, err := collection.CountDocuments(ctx, bson.M{
		"user_id":    userID,
		"product_id": productID,
	})
	if err != nil {
		return false, err
	}

	return count > 0, nil
}

// GetAllUserPurchases retrieves all user purchases (for recommendation algorithm)
func (r *interactionRepository) GetAllUserPurchases(ctx context.Context) ([]domain.UserProductPurchase, error) {
	collection := r.db.Collection("user_product_purchases")

	opts := options.Find().SetSort(bson.M{"purchased_at": -1})
	cursor, err := collection.Find(ctx, bson.M{}, opts)
	if err != nil {
		return nil, fmt.Errorf("get all purchases: %w", err)
	}
	defer cursor.Close(ctx)

	var purchases []domain.UserProductPurchase
	if err := cursor.All(ctx, &purchases); err != nil {
		return nil, fmt.Errorf("decode purchases: %w", err)
	}

	return purchases, nil
}
